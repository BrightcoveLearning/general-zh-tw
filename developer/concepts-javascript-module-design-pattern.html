---
title: 'JavaScript 模塊設計模式'
parent: Developers 
---

<article class="bcls-article">
  <h1>概念：JavaScript 模塊設計模式</h1>
  <summary>在本主題中，您將學習如何使用JavaScript模塊設計模式來減少代碼與網頁上其他腳本衝突的機會。</summary>
  <section class="bcls-section">
    <h2 id="Scope_conflicts">範圍衝突</h2>
    <p>在JavaScript中，當您使用<code translate="No">var</code>元素，它的作用域在定義的函數中。如果不使用而定義變量<code translate="No">var</code>，然後為其分配了全局範圍。這意味著全局變量很容易與頁面上的其他腳本發生衝突。</p>
    <p>讓我們看一個代碼示例。在以下代碼中，函數和變量存在於頁面範圍內。</p>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">// script 1
var incrementCount = function() {
    count++;
}

var myButton = document.getElementById('buttonId');
var count = 0;

myButton.onclick = incrementCount;</code></pre>
    <p>現在，假設腳本之外有一個函數也可以修改全局變量<code translate="No">count</code>多變的。腳本的這種衝突可能會導致意外的結果。</p>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">// script 2
var countVideos = function(videoList) {
    count = videoList.length;
}</code></pre>
    <p>結果：</p>
    <ol>
      <li>用戶選擇<code translate="No">myButton</code>按鈕兩次，增加<code translate="No">count</code>可變的<code translate="No">script 1</code>。
        <ul>
          <li><code translate="No">count</code> = <strong> 2個</strong></li>
        </ul>
      </li>
      <li>這<code translate="No">countvideos</code>調用存在於其中的函數<code translate="No">Script 2</code>，也可以在您的網頁上。假設<code translate="No">videoList</code>包含10個項目。現在<code translate="No">count</code>全局變量的值為<strong>10</strong>。
        <ul>
          <li><code translate="No">count</code> = <strong> 10</strong></li>
        </ul>
      </li>
      <li>下次用戶選擇<code translate="No">myButton</code>按鈕，<code translate="No">count</code>變量將返回意外結果。
        <ul>
          <li>預期的：<code translate="No">count</code> = <strong> 3</strong></li>
          <li>實際的：<code translate="No">count</code> = <strong> 11</strong></li>
        </ul>
      </li>
    </ol>
    <p>您可以嘗試避免腳本中的衝突，但是不能保證頁面中包含的第三方腳本不會使用相似的函數和變量名。</p>
  </section>
  <section class="bcls-section">
    <h2 id="Anonymous_functions">匿名功能</h2>
    <p>一種解決方案是將代碼包裝在匿名函數（也稱為閉包）中，該函數立即執行。其他腳本無法訪問閉包內的代碼。因此，這為您提供了一種創建私有函數和變量的方法。</p>
    <p>這是匿名函數的語法：</p>
    <ul>
      <li>第3行：包含了另一組括號，該括號告訴JavaScript在解析函數後立即執行該函數，而不是等待其他代碼來調用該函數。</li>
    </ul>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">(function () {
    // your code
}<span class="bcls-highlight">()</span>);</code></pre>
    <p>封閉功能強大，因為它們在應用程序的整個生命週期內都提供隱私和狀態。對於閉包內部的代碼，所有變量和函數僅在閉包範圍內。但是，閉包內部的代碼仍然可以訪問任何全局變量或函數。</p>
  </section>
  <section class="bcls-section">
    <h2 id="Globals">全球</h2>
    <p>儘管JavaScript具有稱為“隱含全局變量"的功能，但由於難以確定哪些變量是全局變量，因此可能使您的代碼難以管理。為了確定變量是否為全局變量，解釋器必須在範圍鏈中向後移動以尋找變量。<code translate="No">var</code>名稱匹配的語句。如果未找到任何變量，則假定該變量為全局變量。</p>
    <h3>傳遞全局</h3>
    <p>使用匿名函數，您可以顯式傳遞全局參數。這稱為將參數導入代碼中。</p>
    <p>這是一個例子：</p>
    <ul>
      <li>第1行：定義傳遞給函數的參數的名稱。請注意，它們不必與第3行中的名稱匹配。在這裡，<code translate="No">window</code>對像被傳遞到名為<code translate="No">window1</code>。</li>
      <li>第3行：通過<code translate="No">window</code>對象放入函數中。</li>
    </ul>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">(function( window1, undefined ) {
    ...
})(window);</code></pre>
    <p>由於僅傳遞了1個對象，但是有兩個參數，即<code translate="No">undefined</code>將是不確定的。</p>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">typeof undefined == "undefined"</code></pre>
    <p>如果您想要一種簡單的方法來檢查是否定義了其他變量，這將很方便。</p>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">if(variable1 === undefined)</code></pre>
    <h3>出口全球</h3>
    <p>您可能還希望在匿名函數之外傳遞變量和函數。您可以使用<code translate="No">return</code>價值。</p>
    <p>這是一個例子：</p>
    <ul>
      <li>第1行：將我們的匿名函數分配給<code translate="No">BCLS</code>。該值可以是您選擇的任何值。在此示例中，我們使用BCLS（Brightcove學習服務）。</li>
    </ul>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">var BCLS = (function( window1, undefined ) {
    var object1 = {};
    object1.count = 1;
    object1.method = function () {
        ...
    }
    <span class="bcls-highlight">return object1;</span>
})(window);</code></pre>
    <p>這<code translate="No">object1</code>對象現在在全球範圍內具有兩個公共屬性，即一個名為<code translate="No">count</code>和一個名為<code translate="No">method</code>。可以在我們的匿名功能之外通過以下方式訪問它們：</p>
    <ul>
      <li><code translate="No">BCLS.object1.count</code></li>
      <li><code translate="No">BCLS.object1.method</code></li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Complete_example">完整的例子</h2>
    <p>這是JavaScript模塊設計模式的一些完整示例。</p>
    <h3>例子1</h3>
    <p>本示例說明如何使用模塊模式創建私有和公共變量和函數。</p>
    <ul>
      <li>私有變量：<code translate="No">myvar</code>，<code translate="No">myvar2</code></li>
      <li>私人職能：<code translate="No">fname</code>，<code translate="No">fname2</code></li>
      <li>公共變量：<code translate="No">myvar3</code></li>
      <li>公共職能：<code translate="No">fname3</code></li>
    </ul>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">var BCLS = ( function() {
   var myvar = value,
       myvar2 = value;

   fname = function() {
        ...
   };
   fname2 = function() {
        ...
   };

   return {
        fname3 : function() {
             ...
        },
        myvar3 = value;
   };
}());</code></pre>
    <h3>例子2</h3>
    <p>此示例傳入全局對象，並公開一個公共函數。</p>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">var BCLS = (function( window, document, videojs ) {
    var myvar = value;

    // use a global object passed into the anonymous function
    videojs.registerPlugin('overlay');

    fname = function() {
        ...
    }
    return {
      fname2 : function() {
            ...
        }
    }
})(window, document, videojs);

// call the public function fname2
var newvar = BCLS.fname2();</code></pre>
  </section>
  <section class="bcls-section">
    <h2 id="Code_samples">程式碼範例</h2>
    <p>我們的一些代碼示例使用JavaScript模塊設計模式，您可以查看它們以獲取有關如何實現此模式的想法。</p>
    <ul>
      <li><a href="https://player.support.brightcove.com/code-samples/brightcove-player-sample-floating-player.html">浮動球員</a></li>
    </ul>
  </section>
</article>